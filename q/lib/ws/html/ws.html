<!--
Vibe Code with Claude Sonnect 4.5, ChatGPT & Gemini 3
TODO:
- Update corresponding disabled symbols
- onerror calls onclose "Connection closed unexpectedly" even when connection is not opened
- Copy all, want q)query to be on same line (same for highlight and copy if possible)
  - Copied popup on the top after clicking copy all - similar to copy code block logic in markdown
- Tooltip for toggles
-->

<!DOCTYPE html>
<html>
  <head>
    <title>kdb+/q WebSocket REPL</title>
    <link rel="icon" type="image/svg+xml" media="(prefers-color-scheme: dark)" href="data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2360a5fa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'> <path d='M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z'/> </svg>">
    <link rel="icon" type="image/svg+xml" media="(prefers-color-scheme: light)" href="data:image/svg+xml, <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'> <path d='M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z'/> </svg>">
    <style>

* { margin: 0; padding: 0; box-sizing: border-box; font-family: "JetBrains Mono", monospace; }

body {
  height: 100vh;
  display: flex;
  flex-direction: column;
  transition: background-color 0.2s, color 0.2s;
}
body.dark { background: #111827; color: #f3f4f6; }
body.light { background: #ffffff; color: #1f2937; }

.header {
  border-bottom: 1px solid;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 16px;
}
.header h1 {
  font-size: 18px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dark .header { background: #1f2937; border-color: #374151; }
.light .header { background: #f9fafb; border-color: #e5e7eb; }

.terminal-icon { width: 20px; height: 20px; color: #60a5fa; }

.header-controls { display: flex; align-items: center; gap: 12px; }

/* Status Pulse Animation */
@keyframes pulse {
  0% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(1.1); }
  100% { opacity: 1; transform: scale(1); }
}
.status {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}
.status.connected .status-icon { animation: pulse 2s infinite ease-in-out; color: #34d399; }
.status.disconnected { color: #ef4444; }
.status.clickable { cursor: pointer; }
.status-icon { width: 16px; height: 16px; }

.server-controls { display: flex; gap: 8px; align-items: center; }

.server-protocol {
  padding: 6px 8px;
  border: 1px solid;
  border-radius: 4px 0 0 4px;
  font-size: 14px;
  cursor: pointer;
  border-right: none;
}
.server-protocol:focus { outline: none; border-color: #3b82f6; }
.dark .server-protocol { background: #111827; border-color: #374151; color: #f3f4f6; }
.light .server-protocol { background: #ffffff; border-color: #d1d5db; color: #1f2937; }

.server-input {
  padding: 6px 12px;
  border: 1px solid;
  border-radius: 4px;
  font-size: 14px;
  width: 200px;
}
.server-input:focus { outline: none; border-color: #3b82f6; }
.dark .server-input { background: #111827; border-color: #374151; color: #f3f4f6; }
.light .server-input { background: #ffffff; border-color: #d1d5db; color: #1f2937; }

.btn {
  border: none;
  padding: 6px 16px;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}
.btn:disabled { opacity: 0.5; cursor: not-allowed; }

.btn-green { background: #10b981; color: white; }
.btn-green:hover { background: #059669; }
.btn-red { background: #ef4444; color: white; }
.btn-red:hover { background: #dc2626; }

.header-right {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 12px;
}

.toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  cursor: pointer;
}

/* Hide default checkboxes */
.toggle input { display: none; }
/* Icon Styling */
.toggle-icon {
  width: 18px;
  height: 18px;
  opacity: 0.5;
  transition: all 0.2s;
}
.toggle span { font-size: 13px; }
/* Active State: Icon lights up and label stays clear */
.toggle input:checked + .toggle-icon {
  opacity: 1;
  color: #60a5fa;
  filter: drop-shadow(0 0 3px rgba(96, 165, 250, 0.5));
}

.dark .toggle:hover .toggle-icon { opacity: 0.9; }
.theme-switch { position: relative; width: 52px; height: 26px; }
.theme-switch input { display: none; }
.theme-switch input:checked + .slider { background: #fde68a; }
.theme-switch input:checked + .slider::before {
  transform: translateX(26px);
  content: "‚òÄÔ∏è";
  background: #facc15;
}

.slider {
  position: absolute;
  inset: 0;
  background: #0f172a;
  border-radius: 999px;
  transition: 0.3s;
}
.slider::before {
  content: "üåô";
  position: absolute;
  height: 22px;
  width: 22px;
  left: 2px;
  top: 2px;
  background: #38bdf8;
  border-radius: 50%;
  display: grid;
  place-items: center;
  transition: 0.3s;
}

.icon-btn {
  background: transparent;
  border: none;
  padding: 8px;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.icon-btn svg { width: 18px; height: 18px; }
.dark .icon-btn { color: #d1d5db; }
.light .icon-btn { color: #4b5563; }
.dark .icon-btn:hover { background: #374151; }
.light .icon-btn:hover { background: #e5e7eb; }

.main-container { flex: 1; display: flex; overflow: hidden; }

.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.input-section { border-bottom: 1px solid; padding: 16px; }
.dark .input-section { background: #1f2937; border-color: #374151; }
.light .input-section { background: #f9fafb; border-color: #e5e7eb; }

.input-row { display: flex; gap: 8px; align-items: start; }

.input-prompt { color: #34d399; margin-top: 8px; font-size: 14px; }

.input-field {
  flex: 1;
  border: 1px solid;
  border-radius: 4px;
  padding: 8px 12px;
  font-size: 14px;
  resize: vertical;
}
.input-field:focus { outline: none; border-color: #3b82f6; }
.input-field:disabled { opacity: 0.5; }
.dark .input-field { background: #111827; border-color: #374151; color: #f3f4f6; }
.light .input-field { background: #ffffff; border-color: #d1d5db; color: #1f2937; }

.btn-primary { background: #3b82f6; color: white; }
.btn-primary:hover { background: #2563eb; }

.btn-secondary { color: white; }
.dark .btn-secondary { background: #374151; }
.light .btn-secondary { background: #e5e7eb; color: #1f2937; }
.dark .btn-secondary:hover { background: #4b5563; }
.light .btn-secondary:hover { background: #d1d5db; }

.live-output-container {
  margin-top: 12px;
  padding: 12px;
  border: 1px solid;
  border-radius: 4px;
  display: none;
}
.live-output-container.show { display: block; }
.dark .live-output-container { background: #111827; border-color: #374151; }
.light .live-output-container { background: #f3f4f6; border-color: #d1d5db; }

.live-output-label { font-size: 12px; margin-bottom: 4px; }
.dark .live-output-label { color: #6b7280; }
.light .live-output-label { color: #6b7280; }

.live-output { font-size: 14px; white-space: pre-wrap; }

.input-help { margin-top: 8px; font-size: 12px; }
.dark .input-help { color: #6b7280; }
.light .input-help { color: #6b7280; }

.input-help code { padding: 2px 6px; border-radius: 3px; }
.dark .input-help code { background: #111827; color: #9ca3af; }
.light .input-help code { background: #f3f4f6; color: #6b7280; }

.output-header {
  padding: 12px 16px;
  border-bottom: 1px solid;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.dark .output-header { background: #1f2937; border-color: #374151; }
.light .output-header { background: #f9fafb; border-color: #e5e7eb; }

.output-area {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  font-size: 14px;
}
.output-line { margin-bottom: 8px; }
.output-input { display: flex; gap: 8px; }
.output-prompt { color: #34d399; }

.output-text { white-space: pre-wrap; }
.dark .output-text { color: #f3f4f6; }
.light .output-text { color: #1f2937; }

.output-result { padding-left: 24px; white-space: pre-wrap; }
.output-result.error { color: #ef4444; }

.output-info { padding-left: 24px; font-size: 12px; font-style: italic; }
.dark .output-info { color: #6b7280; }
.light .output-info { color: #9ca3af; }

.sidebar {
  width: 350px;
  border-left: 1px solid;
  display: flex;
  flex-direction: column;
  transition: margin-right 0.3s;
}
.sidebar.collapsed { margin-right: -350px; }
.dark .sidebar { background: #1f2937; border-color: #374151; }
.light .sidebar { background: #f9fafb; border-color: #e5e7eb; }

.sidebar-header {
  padding: 12px 16px;
  border-bottom: 1px solid;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.dark .sidebar-header { border-color: #374151; }
.light .sidebar-header { border-color: #e5e7eb; }

.sidebar-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
  font-size: 13px;
}

.history-popup {
  position: fixed;
  top: 30%;
  left: 50%;
  transform: translateX(-50%);
  width: 520px;
  border-radius: 8px;
  z-index: 999;
}
.history-popup.hidden { display: none; }
.dark .history-popup { background: #020617; border: 1px solid #374151; }
.light .history-popup { background: #ffffff; border: 1px solid #d1d5db; }

.history-popup input {
  width: 100%;
  padding: 10px;
  border: none;
  outline: none;
}
.dark .history-popup input { background: #020617; color: #f3f4f6; }
.light .history-popup input { background: #ffffff; color: #1f2937; }

.history-item { padding: 6px 10px; cursor: pointer; }
.history-item:hover { background: #1e293b; }
.history-item.selected { background: #334155; }
.light .history-item.selected { background: #e5e7eb; }

.history-hint {
  font-size: 11px;
  color: #9ca3af;
  margin-bottom: 6px;
  user-select: none;
}

.fuzzy-match { color: #38bdf8; font-weight: 600; }

.log-entry {
  margin-bottom: 8px;
  padding: 8px;
  border-radius: 4px;
  font-size: 12px;
}
.dark .log-entry { background: #111827; }
.light .log-entry { background: #f3f4f6; }

.log-timestamp { font-size: 11px; margin-bottom: 4px; }
.dark .log-timestamp { color: #6b7280; }
.light .log-timestamp { color: #9ca3af; }

.log-message.error { color: #ef4444; }
.log-message.success { color: #34d399; }
.dark .log-message.info { color: #d1d5db; }
.light .log-message.info { color: #4b5563; }

.hidden { display: none; }

    </style>
  </head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <body class="dark">

    <div class="header">
      <h1>
        <svg class="terminal-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
        </svg>
        kdb+/q WebSocket REPL
      </h1>

      <div class="header-controls">
        <div class="status disconnected clickable" id="status" title="Click to toggle server settings">
          <svg class="status-icon" width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="12" r="8"/>
          </svg>
          <span id="statusText">Disconnected</span>
        </div>

        <div id="serverControls" class="server-controls">
          <select class="server-protocol" id="serverProtocol">
            <option value="ws://">ws://</option>
            <option value="wss://">wss://</option>
          </select>
          <input type="text" class="server-input" id="serverUrl" value="localhost:5000">
          <button class="btn btn-green" id="connectBtn">Connect</button>
        </div>
      </div>

      <div class="header-right">
        <label class="toggle" title="Live Mode (Evaluate as you type)">
          <input type="checkbox" id="liveMode">
          <svg class="toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
          </svg>
          <span>Live</span>
        </label>

        <label class="toggle" title="Show Metadata (Timestamps/Roundtrip)">
          <input type="checkbox" id="showInfo">
          <svg class="toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          <span>Info</span>
        </label>

        <label class="toggle" title="Multi-line Editor">
          <input type="checkbox" id="multilineMode">
          <svg class="toggle-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"/>
          </svg>
          <span>Multi</span>
        </label>

        <label class="theme-switch">
          <input type="checkbox" id="lightMode">
          <span class="slider"></span>
        </label>

        <button class="icon-btn" id="toggleSidebarBtn">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M4 4h16v16H4z M9 4v16"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="main-container">
      <div class="content-area">
        <div class="input-section">
          <div class="input-row">
            <span class="input-prompt">q)</span>
            <textarea class="input-field" id="input" rows="1" placeholder="Enter q expression (press Enter to execute)" disabled></textarea>
            <button class="btn btn-primary" id="runBtn" disabled>Run</button>
            <button class="btn btn-secondary" id="clearInputBtn">Clear</button>
          </div>

          <div class="live-output-container" id="liveContainer">
            <div class="live-output-label">Live Output:</div>
            <div class="live-output" id="liveOutput">Evaluating ...</div>
          </div>

          <div class="input-help" id="helpText">
            Enter the Server URL and click Connect
          </div>
        </div>

        <div class="output-header">
          <span>Console</span>
          <div style="display: flex; gap: 8px;">
            <button class="icon-btn" id="clearOutputBtn" title="Clear output">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862 a2 2 0 01-1.995-1.858L5 7 m5 4v6m4-6v6 M9 7V4a1 1 0 011-1h4a1 1 0 011 1v3 M4 7h16"/>
              </svg>
            </button>
            <button class="icon-btn" id="copyAllBtn" title="Copy to clipboard">
              <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="output-area" id="output"></div>
      </div>

      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
          Connection Logs
          <button class="icon-btn" id="clearLogsBtn">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
            </svg>
          </button>
        </div>
        <div class="sidebar-content" id="logs"></div>
      </div>
    </div>

    <!-- History Search Popup -->
    <div id="historyPopup" class="history-popup hidden">
      <div id="historyHint" class="history-hint"></div>
      <input id="historySearch" placeholder="Reverse Search ..." />
      <div id="historyResults"></div>
    </div>

    <script src="c.js"></script>
    <script>

// ================================
// Runtime State
// ================================
let ws = null;
let isConnected = false;
let isLiveMode = false;
let multilineMode = false;
let showInfo = false;

let draftInput = "";
let historyFuzzyMode = true;
let historyIndex = -1;
let historySelectionIndex = -1;
let historyTimer = null;
let lastSendTime = null;
let liveTimer = null;

const cmdHistory = [];
const historyTimerMs = 150;
const liveTimerMs = 300;

// ================================
// Cached DOM Elements
// ================================
const outputEl = document.getElementById("output");
const inputEl = document.getElementById("input");
const runBtn = document.getElementById("runBtn");
const helpText = document.getElementById("helpText");

const historyPopup = document.getElementById("historyPopup");
const historySearch = document.getElementById("historySearch");
const historyResults = document.getElementById("historyResults");

const liveContainer = document.getElementById("liveContainer");
const liveOutputEl = document.getElementById("liveOutput");

const statusEl = document.getElementById("status");
const statusText = document.getElementById("statusText");
const connectBtn = document.getElementById("connectBtn");
const serverUrlInput = document.getElementById("serverUrl");

const sidebar = document.getElementById("sidebar");
const logsEl = document.getElementById("logs");

// ================================
// Event Bindings
// ================================
statusEl.addEventListener("click", toggleServerControls);
connectBtn.addEventListener("click", toggleConnection);

document.getElementById("liveMode").addEventListener("change", toggleLiveMode);
document.getElementById("showInfo").addEventListener("change", toggleShowInfo);
document.getElementById("multilineMode").addEventListener("change", toggleMultilineMode);
document.getElementById("lightMode").addEventListener("change", toggleLightMode);
document.getElementById("toggleSidebarBtn").addEventListener("click", toggleSidebar);

inputEl.addEventListener("input", handleInput);
inputEl.addEventListener("keydown", handleKeyDown);
runBtn.addEventListener("click", executeCode);

document.getElementById("clearLogsBtn").addEventListener("click", clearLogs);
document.getElementById("clearInputBtn").addEventListener("click", clearInput);
document.getElementById("clearOutputBtn").addEventListener("click", clearOutput);
document.getElementById("copyAllBtn").addEventListener("click", copyAllOutput);

// ================================
// UI Toggle & Mode Handlers
// (theme, sidebar, live, multiline, info)
// ================================
function toggleLiveMode() {
  isLiveMode = document.getElementById("liveMode").checked;
  applyLiveUI();
  updateHelpText();
}

function toggleMultilineMode() {
  multilineMode = document.getElementById("multilineMode").checked;
  applyMultilineUI();
  updateHelpText();
}

function toggleLightMode() {
  var isLight = document.getElementById("lightMode").checked;
  document.body.className = isLight ? "light" : "dark";
}

function toggleShowInfo() { showInfo = document.getElementById("showInfo").checked; }
function toggleSidebar() { sidebar.classList.toggle("collapsed"); }

// ================================
// Command History & Reverse Search
// ================================
function openHistoryPopup() {
  historyPopup.classList.remove("hidden");
  historySearch.value = historyResults.innerHTML = "";
  updateHistoryHint();
  historySearch.focus();
  renderHistory("");
}

function closeHistoryPopup() {
  historyPopup.classList.add("hidden");
  inputEl.focus();
}

function renderHistory(filter) {
  historyResults.innerHTML = "";
  historySelectionIndex = -1;

  if (!filter) {
    cmdHistory.slice().reverse().forEach(cmd => {
      const div = document.createElement("div");
      div.className = "history-item";
      div.textContent = cmd;
      div.addEventListener("click", () => {
        inputEl.value = cmd;
        closeHistoryPopup();
      });
      historyResults.appendChild(div);
    });
    return;
  }

  if (!historyFuzzyMode) {
    cmdHistory.slice().reverse().forEach(cmd => {
      if (!cmd.includes(filter)) return;
      const div = document.createElement("div");
      div.className = "history-item";
      div.innerHTML = escapeHtml(cmd).replace(
        filter,
        `<span class="fuzzy-match">${escapeHtml(filter)}</span>`
      );
      div.addEventListener("click", () => {
        inputEl.value = cmd;
        closeHistoryPopup();
      });
      historyResults.appendChild(div);
    });
    return;
  }

  // fuzzy mode
  const scored = cmdHistory
    .map(cmd => ({ cmd, score: fuzzyScore(filter, cmd) }))
    .filter(x => x.score >= 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, 20);

  for (const { cmd } of scored) {
    const div = document.createElement("div");
    div.className = "history-item";
    div.innerHTML = highlightFuzzyMatch(filter, cmd);
    div.addEventListener("click", () => {
      inputEl.value = cmd;
      closeHistoryPopup();
    });
    historyResults.appendChild(div);
  }
}

function updateHistoryHint() {
  const hint = document.getElementById("historyHint");
  hint.textContent = "Fuzzy-mode " + (historyFuzzyMode ? "en" : "dis") + "abled (Press Ctrl+r to toggle)";
}

function fuzzyScore(query, text) {
  let score = 0;
  let ti = 0;
  let streak = 0;

  for (let qi = 0; qi < query.length; qi++) {
    const qc = query[qi].toLowerCase();
    let found = false;

    while (ti < text.length) {
      if (text[ti].toLowerCase() === qc) {
        found = true;
        streak++;
        score += 10 + streak * 5;
        ti++;
        break;
      } else {
        streak = 0;
        ti++;
      }
    }
    if (!found) return -1;
  }

  score += Math.max(0, 30 - ti);
  score -= text.length * 0.1;
  return score;
}

function highlightFuzzyMatch(query, text) {
  let qi = 0;
  let out = "";

  for (let i = 0; i < text.length; i++) {
    if (
      qi < query.length &&
      text[i].toLowerCase() === query[qi].toLowerCase()
    ) {
      out += `<span class="fuzzy-match">${escapeHtml(text[i])}</span>`;
      qi++;
    } else {
      out += escapeHtml(text[i]);
    }
  }
  return out;
}

function historyUp(event) {
  event.preventDefault();
  // Save latest draft input
  if (historyIndex === cmdHistory.length) {
    draftInput = inputEl.value;
  }
  if (historyIndex > 0) {
    historyIndex--;
    inputEl.value = cmdHistory[historyIndex];
  }
}

function historyDown(event) {
  event.preventDefault();
  if (historyIndex < cmdHistory.length - 1) {
    historyIndex++;
    inputEl.value = cmdHistory[historyIndex];
  } else {
    historyIndex = cmdHistory.length;
    // Restore latest draft input
    inputEl.value = draftInput;
  }
}

historySearch.addEventListener("input", function () {
  clearTimeout(historyTimer);
  historyTimer = setTimeout(() => renderHistory(historySearch.value), historyTimerMs);
});

historySearch.addEventListener("keydown", function (e) {
  const items = historyResults.children;

  if (e.key === "Enter") {
    e.preventDefault();
    if (historySelectionIndex >= 0) {
      inputEl.value = items[historySelectionIndex].textContent;
    }
    closeHistoryPopup();
    return;
  } else if (e.key === "Escape") {
    closeHistoryPopup();
    return;
  }

  if (!items.length) return;

  if (e.key === "ArrowDown" || e.key === "ArrowUp") {
    e.preventDefault();

    if (historySelectionIndex === -1) {
      historySelectionIndex = e.key === "ArrowUp" ? items.length - 1 : 0;
    } else {
      historySelectionIndex += e.key === "ArrowDown" ? 1 : -1;
      if (historySelectionIndex < 0) {
        historySelectionIndex = items.length - 1;
      } else if (historySelectionIndex >= items.length) {
        historySelectionIndex = 0;
      }
    }

    // Update highlight
    Array.from(items).forEach((el, i) =>
      el.classList.toggle("selected", i === historySelectionIndex)
    );
  }
});

document.addEventListener("keydown", function (e) {
  // Ctrl+R / Cmd+R
  if ((e.ctrlKey || e.metaKey) && e.key === "r") {
    e.preventDefault();

    if (!isConnected) return false;

    if (historyPopup.classList.contains("hidden")) {
      openHistoryPopup();
    } else {
      // toggle fuzzy / plain mode
      historyFuzzyMode = !historyFuzzyMode;
      updateHistoryHint();
      renderHistory(historySearch.value);
    }
    return false;
  }
});

document.addEventListener("mousedown", function (e) { if (!historyPopup.classList.contains("hidden") && !historyPopup.contains(e.target)) closeHistoryPopup(); });

// ================================
// Connection Lifecycle (WebSocket)
// ================================
function toggleConnection() { isConnected ? disconnect() : connect(); }
function disconnect() { if (ws) ws.close(); }

function connect() {
  if (!("WebSocket" in window)) {
    alert("WebSocket not supported on your browser");
    return;
  }

  const protocol = document.getElementById("serverProtocol").value;
  const hostPort = serverUrlInput.value.trim();

  // Validate host:port
  if (!hostPort) {
    addLog("error", "Please enter host:port (e.g., localhost:5000)");
    return;
  }
  // Basic validation for host:port format
  if (!hostPort.match(/^[a-zA-Z0-9.-]+(:\d+)?$/)) {
    addLog("error", "Invalid format. Use: hostname:port");
    return;
  }

  const wsUrl = protocol + hostPort;

  addLog("info", "Connecting to " + wsUrl + " ...");

  try {
    ws = new WebSocket(wsUrl);
    ws.binaryType="arraybuffer";

    ws.onopen = function(e) {
      addLog("success", "Connected to kdb+ server at " + wsUrl);
      updateConnectionState(true);
      focusInput();
    };

    ws.onclose = function(e) {
      if (e.wasClean) {
        addLog("info", "Disconnected from server");
      } else {
        addLog("error", "Connection closed unexpectedly");
      }
      updateConnectionState(false);
    };

    ws.onmessage = function(e) {
      var result = deserialize(e.data);
      var roundtrip = lastSendTime ? Date.now() - lastSendTime : null;

      if (isLiveMode && document.activeElement === inputEl && inputEl.value.trim()) {
        liveOutputEl.textContent = result;
      } else {
        addOutput("result", result, roundtrip);
      }
      lastSendTime = null;
    };

    ws.onerror = function(e) {
      addLog("error", "Check if the kdb+ Server is running");
    };
  } catch (err) {
    addLog("error", "Failed to create WebSocket: " + err.message);
    return;
  }
}

function updateConnectionState(connected) {
  isConnected = connected;
  renderUI();
}

// ================================
// UI Rendering & State Application
// ================================
function applyConnectionUI() {
  const protocolSelect = document.getElementById("serverProtocol");

  serverUrlInput.disabled = isConnected;
  protocolSelect.disabled = isConnected;
  serverUrlInput.style.opacity = isConnected ? "0.5" : "1";
  protocolSelect.style.opacity = isConnected ? "0.5" : "1";

  statusText.textContent = isConnected ? "Connected" : "Disconnected";
  statusEl.className = "status " + statusText.textContent.toLowerCase() + " clickable";

  connectBtn.textContent = isConnected ? "Disconnect" : "Connect";
  connectBtn.classList.toggle("btn-green", !isConnected);
  connectBtn.classList.toggle("btn-red", isConnected);

  runBtn.disabled = inputEl.disabled = !isConnected;
}

function renderUI() {
  applyConnectionUI();
  applyLiveUI();
  applyMultilineUI();
  updateHelpText();
}

function applyLiveUI() { liveContainer.classList.toggle("show", isLiveMode && isConnected); }
function applyMultilineUI() { inputEl.rows = multilineMode ? 5 : 1; }

function updateHelpText() {
  if (!isConnected) {
    helpText.textContent = "Enter the Server URL and click Connect";
    return;
  }
  const searchHelp = "Press Ctrl+r to toggle Search History";
  let messages = [];
  if (isLiveMode) messages.push("Live mode enabled ‚Ä¢ Code evaluates as you type");
  if (multilineMode) messages.push("Multi-line mode enabled ‚Ä¢ Press Ctrl+Enter to execute ‚Ä¢ " + searchHelp);
  if (!isLiveMode && !multilineMode) messages.push("Press Enter to execute ‚Ä¢ Press ‚Üë‚Üì to scroll history ‚Ä¢ " + searchHelp);
  helpText.innerHTML = messages.join("<br>");
}

function focusInput() {
  if (!inputEl.disabled) {
    inputEl.focus();
    inputEl.selectionStart = inputEl.selectionEnd = inputEl.value.length;
  }
}

// ================================
// Output & Logging Helpers
// ================================
function addLog(type, message) {
  var entry = document.createElement("div");
  entry.className = "log-entry";

  var timestamp = new Date().toISOString().replace("T", "D").replace("Z", "");

  entry.innerHTML =
    '<div class="log-timestamp">' + timestamp + "</div>" +
      '<div class="log-message ' + type + '">' + escapeHtml(message) + "</div>";

  logsEl.appendChild(entry);
  logsEl.scrollTop = logsEl.scrollHeight;
}

function clearLogs() { logsEl.innerHTML = ""; }

function addOutput(type, content, roundtrip) {
  var line = document.createElement("div");
  line.className = "output-line";

  if (type === "input") {
    line.innerHTML = '<div class="output-input"><span class="output-prompt">q)</span><span class="output-text">' + highlightQ(content) + "</span></div>";
  } else if (type === "result") {
    const isError = content.startsWith("'");
    const cls = isError ? "output-result error" : "output-result";

    line.innerHTML = '<div class="' + cls + '">' + (isError ? escapeHtml(content) : highlightQ(content)) + "</div>";

    if (showInfo && roundtrip !== null) {
      var timestamp = new Date().toISOString().replace("T", "D").replace("Z", "");
      var info = document.createElement("div");
      info.className = "output-info";
      info.textContent = "(" + timestamp + ", roundtrip: " + roundtrip + "ms)";
      line.appendChild(info);
    }
  }

  outputEl.appendChild(line);
  outputEl.scrollTop = outputEl.scrollHeight;
}

function clearOutput() { outputEl.innerHTML = ""; }

function copyAllOutput() {
  const btn = document.getElementById("copyAllBtn");

  // Select all output lines and join their textContent
  const lines = Array.from(outputEl.querySelectorAll('.output-line'))
  .map(line => line.innerText)
  .join('\n');

  if (!lines) return;

  navigator.clipboard.writeText(lines).then(() => {
    // Visual feedback: change icon color temporarily
    const originalColor = btn.style.color;
    btn.style.color = "#34d399";
    setTimeout(() => btn.style.color = originalColor, 1000);
  }).catch(err => {
      console.error('Failed to copy: ', err);
    });
}

function escapeHtml(text) {
  var div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

// ================================
// Code Execution & Keyboard Handling
// ================================
function executeCode() {
  const code = inputEl.value.trim();
  if (!code) return;

  cmdHistory.push(code);
  historyIndex = cmdHistory.length;

  if (!ws || ws.readyState !== WebSocket.OPEN) {
    addLog("error", "Not connected to server");
    return;
  }

  addOutput("input", code);
  lastSendTime = Date.now();
  ws.send(code);
  inputEl.value = "";
  liveOutputEl.textContent = "Evaluating ...";
}

function handleKeyDown(event) {
  if (multilineMode) {
    if (event.ctrlKey && event.key === "Enter") {
      event.preventDefault();
      executeCode();
    } else if (event.key === "Tab") {
      event.preventDefault();
      const start = inputEl.selectionStart;
      const end = inputEl.selectionEnd;
      const value = inputEl.value;
      inputEl.value = value.slice(0, start) + "  " + value.slice(end);
      inputEl.selectionStart = inputEl.selectionEnd = start + 2;
    }
  } else {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      executeCode();
    } else if (event.key === "ArrowUp") {
      historyUp(event);
    } else if (event.key === "ArrowDown") {
      historyDown(event);
    }
  }
  // Ctrl+l clear console
  if (event.ctrlKey && event.key === "l") {
    event.preventDefault();
    clearOutput();
  }
}

// ================================
// Live Mode Input Handling
// ================================
function clearInput() { inputEl.value = liveOutputEl.textContent = ""; }
function handleInput() {
  if (!isLiveMode) return;

  if (!ws || ws.readyState !== WebSocket.OPEN) {
    liveOutputEl.textContent = "Not connected";
    return;
  }

  const code = inputEl.value.trim();
  if (!code) return;
  clearTimeout(liveTimer);
  liveTimer = setTimeout(function() {
    lastSendTime = Date.now();
    ws.send(code);
  }, liveTimerMs);
}

// ================================
// Server Controls UI
// ================================
function toggleServerControls() { document.getElementById("serverControls").classList.toggle("hidden"); }

// ================================
// q Syntax Highlighting Engine
// ================================
const COLORS = {
  keyword:   "#ca72e4",
  number:    "#d99a5e",
  internal:  "#ebc275",
  namespace: "#5ab0f6",
  symbol:    "#4dbdcb",
  string:    "#97ca72",
  comment:   "#64748b",
  constant:  "#4dbdcb",
  temporal:  "#d99a5e",
  boolean:   "#ca72e4",
  command:   "#4dbdcb",
  escape:    "#2ac3de"
};

const PATTERNS = [
  // Comments (check at start or after whitespace)
  { regex: /^\/.*$/m, color: "comment" },
  { regex: /(?<=^|\s)\/.*$/m, color: "comment" },
  // Strings
  { regex: /"(?:[^"\\]|\\.)*"?/, color: "string" },
  // Symbols - entire backtick expression
  { regex: /`(?::[A-Za-z0-9_.:/]*|[A-Za-z0-9_.]*)/, color: "symbol" },
  // Temporal types
  { regex: /\b([12]\d{3}\.(0[1-9]|1[0-2])\.(0[1-9]|[12]\d|3[01]))D([01]\d|2[0-3])(?::([0-5]\d)(?::([0-5]\d(?:\.\d{0,9})?))?)?p?\b/, color: "temporal" },
  { regex: /\b([12]\d{3}\.(0[1-9]|1[0-2])\.(0[1-9]|[12]\d|3[01]))T([01]\d|2[0-3])(?::([0-5]\d)(?::([0-5]\d(?:\.\d{0,3})?))?)?z?\b/, color: "temporal" },
  { regex: /\b([12]\d{3}\.(0[1-9]|1[0-2])\.(0[1-9]|[12]\d|3[01]))(?:p|D|Dp|z|T|Tz)\b/, color: "temporal" },
  { regex: /\b([12]\d{3}\.(0[1-9]|1[0-2])\.(0[1-9]|[12]\d|3[01]))\b/, color: "temporal" },
  { regex: /\b([12]\d{3}\.(0[1-9]|1[0-2])m)\b/, color: "temporal" },
  { regex: /\b([01]\d|2[0-3])(?::([0-5]\d)(?::([0-5]\d(?:\.\d{0,3})?))?)\b/, color: "temporal" },
  { regex: /\b\d+D(?:([01]\d|2[0-3])(?::([0-5]\d)(?::([0-5]\d(?:\.\d{0,9})?))?)?)?n?\b/, color: "temporal" },
  // Null values
  { regex: /\b0N[ghijepmdznuvt]?\b/, color: "constant" },
  { regex: /\b0n\b/, color: "constant" },
  // Infinity
  { regex: /\b-?0W[hijepdnutv]?\b/, color: "constant" },
  { regex: /\b-?0wz?\b/, color: "constant" },
  // Booleans
  { regex: /\b[01]+b\b/, color: "boolean" },
  // Internal functions (.z, .Q, .h, .j)
  { regex: /\.(Q|z|h|j)\.[A-Za-z0-9_]+/, color: "internal" },
  // Cast operators and internal functions
  { regex: /\b[0-2]:/, color: "internal" },
  { regex: /-(?:[1-9]|1[0-689]|2[0-79]|3[01368]|120)!/, color: "internal" },
  // General namespaces (but not .z, .Q, .h, .j)
  { regex: /\.(?!z\.|Q\.|h\.|j\.|[0-2]:)[A-Za-z][A-Za-z0-9_]*(?:\.[A-Za-z0-9_]+)+/, color: "namespace" },
  // Numbers with type suffixes
  { regex: /\b0x[0-9a-fA-F]+\b/, color: "number" },
  { regex: /\b\d+[fhij]\b/, color: "number" },
  { regex: /\b\d+\.\d*(?:e[+-]?\d+)?\b/, color: "number" },
  { regex: /\.\d+(?:e[+-]?\d+)?\b/, color: "number" },
  { regex: /\b\d+e[+-]?\d+\b/, color: "number" },
  { regex: /\b\d+\b/, color: "number" },
  // Commands (lines starting with backslash)
  { regex: /^\\.+$/m, color: "command" },
  // Keywords - DML operations
  { regex: /\b(select|update|delete|exec|from|by|fby|where|aj|aj0|ajf|ajf0|ej|ij|ijf|lj|ljf|uj|ujf|wj|wj1|upsert|insert)\b/, color: "keyword" },
  // Conditionals
  { regex: /\b(do|while|if)\b/, color: "keyword" },
  // Other keywords
  { regex: /\b(abs|acos|all|and|any|asc|asin|asof|atan|attr|avg|avgs|bin|binr|ceiling|cols|cor|cos|count|cov|cross|csv|cut|deltas|desc|dev|differ|distinct|div|dsave|each|ema|enlist|eval|except|exit|exp|fills|first|fkeys|flip|floor|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|idesc|in|inter|inv|key|keys|last|like|load|log|lower|lsq|ltime|ltrim|mavg|max|maxs|mcount|md5|mdev|med|meta|min|mins|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|prd|prds|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|set|setenv|show|signum|sin|sqrt|ss|ssr|string|sublist|sum|sums|sv|svar|system|tables|tan|til|trim|type|ungroup|union|upper|value|var|view|views|vs|wavg|within|wsum|xasc|xbar|xcol|xcols|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/, color: "keyword" }
];

function highlightQ(code) {
  const highlighted = new Array(code.length).fill(false);
  const result = [];

  // Apply each pattern on the original unescaped code
  for (const pattern of PATTERNS) {
    const regex = new RegExp(pattern.regex.source, pattern.regex.flags + "g");
    let match;

    while ((match = regex.exec(code)) !== null) {
      const start = match.index;
      const end = start + match[0].length;

      // Check if this region has already been highlighted
      let alreadyHighlighted = false;
      for (let i = start; i < end; i++) {
        if (highlighted[i]) {
          alreadyHighlighted = true;
          break;
        }
      }

      if (!alreadyHighlighted) {
        // Mark this region as highlighted
        for (let i = start; i < end; i++) {
          highlighted[i] = true;
        }
        result.push({ start, end, color: COLORS[pattern.color], text: match[0], type: pattern.color });
      }
    }
  }

  // Sort by start position
  result.sort((a, b) => a.start - b.start);

  // Build final output with HTML escaping
  let output = "";
  let pos = 0;

  for (const item of result) {
    // Add unhighlighted text before this match (escaped)
    if (pos < item.start) {
      output += escapeHtml(code.substring(pos, item.start));
    }

    // Special handling for strings - highlight escape sequences
    if (item.type === "string") {
      output += highlightString(item.text);
    } else {
      // Add highlighted text (escaped)
      output += `<span style="color:${item.color}">${escapeHtml(item.text)}</span>`;
    }
    pos = item.end;
  }

  // Add remaining unhighlighted text (escaped)
  if (pos < code.length) {
    output += escapeHtml(code.substring(pos));
  }

  return output;
}

function highlightString(str) {
  // Match the opening quote
  let result = `<span style="color:${COLORS.string}">${escapeHtml(str[0])}`;

  let i = 1;
  while (i < str.length) {
    if (str[i] === "\\" && i + 1 < str.length) {
      // Escape sequence - highlight in cyan
      const escapeSeq = str.substring(i, i + 2);
      result += `<span style="color:${COLORS.escape}">${escapeHtml(escapeSeq)}</span>`;
      i += 2;
    } else if (str[i] === '"' && i === str.length - 1) {
      // Closing quote
      result += escapeHtml(str[i]);
      i++;
    } else {
      // Regular character
      result += escapeHtml(str[i]);
      i++;
    }
  }

  result += "</span>";
  return result;
}

    </script>

  </body>
</html>
